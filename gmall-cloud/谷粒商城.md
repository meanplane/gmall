## docker

### 0 命令

```shell
docker images #查看所有镜像
docker image rm ** #删除镜像

docker ps -a #查看所有container
docker rm [containerID] #删除container
docker kill [containerID] #杀死container
docker stop [containerID] 
docker restart [containerID] 

docker container run -p 8000:3000 -it koa-demo /bin/bash
# -it参数:容器的shell映射到当前的shell,你再本机窗口输入的命令,会传入容器.
# -p参数:(-p 3308:3306)容器的 端口映射到本地的端口.

#进入容器
docker attach [containerID] #退出会导致容器终止
docker exec [containerID] #推荐, 退出不会导致容器终止

docker exec -it mysql /bin/bash


```





### 1 mysql

下载镜像: docker pull mysql:5.7

**创建实例并启动**

```shell
docker run -p 3308:3306 --name mysql \
-v /data/mysql/log:/var/log/mysql \
-v /data/mysql/data:/var/lib/mysql \
-v /data/mysql/conf:/etc/mysql \
-e MYSQL_ROOT_PASSWORD=root \
-d mysql:5.7
```

参数说明:

​	-p 3307:3306 将容器的3306 端口映射到主机的3306端口

​	-v /data/mysql/log:/var/log/mysql \  将配置文件夹挂载到主机

​	-v /data/mysql/data:/var/lib/mysql \ 将日志文件挂载到主机

​	-v /data/mysql/conf:/etc/mysql \		将配置文件夹挂载到主机

​	-e MYSQL_ROOT_PASSWORD=root \	初始化root用户的密码



### 2 redis

```shell
mkdir -p /data/redis/conf
touch /data/redis/conf/redis.conf

docker run -p 7001:6379 --name redis \
-v /data/redis/data:/data \
-v /data/redis/conf/redis.conf:/etc/redis/redis.conf \
-d redis redis-server /etc/redis/redis.conf

# 连接redis客户端
docker exec -it redis redis-cli
```



### 3 elasticsearch

```shell
# 下载镜像
docker pull elasticsearch:7.4.2
docker pull kibana:7.4.2

# 创建实例
mkdir -p /data/elasticsearch/config
mkdir -p /data/elasticsearch/data
# 写配置
echo "http.host: 0.0.0.0" >> /data/elasticsearch/config/elasticsearch.properties

# 运行实例 -Xms 限制java占用内存
docker run --name elasticsearch -p 9300:9300 -p 9200:9200 \
-e "discovery.type=single-node" \
-e ES_JAVA_OPT="-Xms64m -Xmx128m" \
-v /data/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \
-v /data/elasticsearch/data:/usr/share/elasticsearch/data \
-v /data/elasticsearch/plugins:/usr/share/elasticsearch/plugins \
-d elasticsearch:7.4.2

```

### 4. Kibana

```shell
docker run --name kibana -e ELASTICSEARCH_HOSTS=http://192.168.88.241:9200 -p 5601:5601 -d kibana:7.4.2
```

### 5. ik分词器

```shell
# 进入es容器内部plugins目录
docker exec -it 容器id /bin/bash
wget ...7.4.2.zip
unzip xxx #解压
rm -rf *.zip
mv elasticsearch/ ik

```







## 技术方案

**SpringCloudAlibaba**

+ Nacos : 注册中心 (服务发现 / 注册)
+ Nacos : 配置中心 (动态配置管理)
+ Ribbon : 负载均衡
+ Feign : 声明式HTTP客户端 (远程调用服务)
+ Sentinel : 服务容错 (限流 , 降级 , 熔断)
+ Gateway : API网关 (webflux 编程模式)
+ Sleuth : 调用链监控
+ Seata : (原 Fescar) 分布式事务解决方案



## nacos

### 注册中心

1. 下载nacos-server 启动 (端口8848)

2. 注册服务pom引入nacos discovery starter

   ```xml
   <dependency>
     <groupId>com.alibaba.cloud</groupId>
     <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
   </dependency>
   ```

3. 配置文件中配置 nacos server地址

   spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848

4. 使用@EnableDiscoveryClient 开启服务注册发现功能

5. 用feign测试服务调用



### 配置中心

1. 引入pom

   ```xml
   <dependency>
     <groupId>com.alibaba.cloud</groupId>
     <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
   </dependency>
   ```

2. resources下创建bootstrap.properties 配置文件 配置nacos config元数据

   ```properties
   spring.application.name=gmall-coupon
   spring.cloud.nacos.config.server-addr=127.0.0.1:8848
   ```

3. 完成上述两步后, 应用会从Nacos.config 中获取相应配置, 并添加在Spring Environment 的PropertySources中. 

   ```java
   @Value("${coupon.tom.name:xxx}")
   private String name;
   @Value("${coupon.tom.age:12}")
   private Integer age;
   
   ```

4. 命名空间

   在bootstrap.properties中配置 spring.cloud.nacos.config.namespace=xxxx区别

5. 配置组

   spring.cloud.nacos.config.group=xxx

## Feign

`声明式远程调用`

> Feign 是一个声明式的HTTP客户端. Feign提供了HTTP请求的模板, 通过编写简单的接口和插入注解, 就可定义好HTTP请求的参数, 格式, 地址 等 信息.
>
> Feign 整合了 Ribbon(负载均衡) 和 Hystrix(服务熔断), 可以让我们不再需要显示的使用这2个组件.
>
> SpringCloudFeign 在NetflixFeign 的基础上扩展了 对 SpringMVC注解的支持, 在其实现下, 我们只需创建一个接口并用注解的方式来配置它, 即可完成服务提供方的接口绑定. 简化了SpringCloudRibbon自行封装服务调用客户端的开发量.

1. pom引入

   ```xml
   <dependency>
     <groupId>org.springframework.cloud</groupId>
     <artifactId>spring-cloud-starter-openfeign</artifactId>
   </dependency>
   ```

2. App开启标签 @EnableFeignClients

3. 定义调用接口

   ```java
   @FeignClient("gmall-coupon")
   public interface CouponFeignService {
       @RequestMapping("/coupon/coupon/member/list")
       public R membercoupons();
   }
   ```

4. 使用

   ```java
   @Autowired
   CouponFeignService couponFeignService;
   
   R membercoupons = couponFeignService.membercoupons();
   ```

## Gateway

> 网关作为流量的入口,常用功能包括路由转发,权限校验,限流控制 等, 而springcloud gateway 作为springcloud官方推出的第二代网关框架, 取代了zuul

1. 引入pom

   ```xml
   ## gateway 是使用netty + webflux 实现,因此不需要引入web模块
   <dependency>
     <groupId>org.springframework.cloud</groupId>
     <artifactId>spring-cloud-starter-gateway</artifactId>
   </dependency>
   ```

2. 配置文件

   ```yaml
   spring:
     application:
       name: gmall-gateway
     cloud:
       nacos:
         discovery:
           server-addr: mplane.cn:8848
       gateway:
         routes:
           - id: test_route
             uri: https://www.baidu.com
             predicates:
               - Query=url,baidu
           - id: qq_route
             uri: https://www.qq.com
             predicates:
               - Query=url,qq
   ```

   id : 自定义路由id

   uri : 目标服务地址

   predicates : 路由条件

3. 



## swagger2

1. pom依赖

   ```xml
   <!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 -->
   <dependency>
      <groupId>io.springfox</groupId>
      <artifactId>springfox-swagger2</artifactId>
      <version>2.9.2</version>
   </dependency>
   <!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui -->
   <dependency>
      <groupId>io.springfox</groupId>
      <artifactId>springfox-swagger-ui</artifactId>
      <version>2.9.2</version>
   </dependency>
   ```

   

2. 配置类

   ```java
   @Configuration //配置类
   @EnableSwagger2// 开启Swagger2的自动配置
   public class SwaggerConfig {  
   }
   ```

### 配置swagger

1. swagger实例bean 是Docket, 所以通过配置Docket实例来配置swagger

   ```java
   @Bean //配置docket以配置Swagger具体参数
   public Docket docket() {
      return new Docket(DocumentationType.SWAGGER_2);
   }
   ```

2. 可以通过apiInfo()属性配置文档信息

   ```java
   //配置文档信息
   private ApiInfo apiInfo() {
      Contact contact = new Contact("联系人名字", "http://xxx.xxx.com/联系人访问链接", "联系人邮箱");
      return new ApiInfo(
              "Swagger学习", // 标题
              "学习演示如何配置Swagger", // 描述
              "v1.0", // 版本
              "http://terms.service.url/组织链接", // 组织链接
              contact, // 联系人信息
              "Apach 2.0 许可", // 许可
              "许可链接", // 许可连接
              new ArrayList<>()// 扩展
     );
   }
   ```

3. Docket实例关联上apiInfo()

   ```java
   @Bean
   public Docket docket() {
      return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo());
   }
   ```

   

## elasticsearch

### 初步检索

#### 1. _cat

```shell
GET /_cat/nodes	查看所有节点
GET /_cat/health	查看es健康状况
GET /_cat/master	查看主节点
GET /_cat/indices	查看所有索引 
```



#### 2. 索引一个文档 (保存)

保存一个数据,保存在哪个索引的哪个类型下,制定用哪个唯一标识

```shell
# PUT customer/external/1; 在customer索引下的external类型下保存1号数据为
PUT customer/external/1
{
	"name":"Jack"
}
# PUT POST都可以
# POST 新增, 如果不指定id,会自动生成id.指定id就会修改这个数据,并新增版本号
# PUT 可以新增修改.PUT必须指定id,否则报错

```



#### 3. 查询文档

```shell
GET customer/external/1
结果:
{
	"_index": "customer",	//索引
	"_type": "external",	//类型
	"_id": "1",						//记录id
	"_version": 2,				//版本号
	"_seq_no": 1,					//并发控制字段,每次更新会+1,用来做乐观锁
	"_primary_term": 1,		//同上,主分片重新分配,如重启就会变化
	"found": true,
	"_source": {
		"brandId": 1,
		"name": "华为"
	}
}
-----------------------------
更新携带 ?if_seq_no=0&if_primary_term=1
```



#### 4. 更新文档

```shell
POST customer/external/1/_update
{
	"doc":{
		"name":"tom"
	}
}
或者
POST customer/external/1
{	"name":"tom"}
或者
PUT customer/external/1
{	"name":"tom"}

## POST操作会比较源数据,带_update 的如果数据没变 则不操作
```

#### 5. 删除

```shell
DELETE customer/external/1
DELETE customer
```



#### 6. bulk 批量 API

```shell
POST customer/external/_bulk
{"index":{"_id":"1"}}
{"name":"tom"}
{"index":{"_id":"2"}}
{"name":"jack"}
 
# bulk API按顺序执行所有的action,如果一个单个的动作因任何原因而失败,他将继续处理后面剩余的动作.当bulk API返回时,将提供每个动作的状态
```

### 进阶检索

#### 1. SearchAPI

ES支持两种基本方式检索

+ 一个是通过使用 REST request URI发送搜索参数 (uri + 检索参数)
+ 一个是通过使用 REST request body 发送 (uri + 请求体)

检索信息

+ 一切检索从search开始

  ```shell
  GET bank/_search		#检索bank下所有信息,包括type 和 docs
  GET bank/_search?q=*&sort=account_number:asc #请求方式检索
  # 响应结果解释
  took #执行时间(毫秒)
  time_out #是否超时
  _shards  #多少个分片被搜索了,以及统计了成功/失败的搜索分片
  hits		 #搜索结果
  hits.total	#搜索结果
  hits.hits		#实际的搜索结果数组(默认为前10的文档)
  sort			#结果的排序 key (没有则按 score 排序 )
  score 和 max_score	#相关性得分和最高得分 (全文检索用)
  ```

  

+ uri + 请求体 进行检索

  ```shell
  GET bank/_search
  {
    "query": {
      "match_all": {}
    },
    "sort":[
      {"account_number": {"order": "desc"}}
    ]
  }
  
  ## 
  ```

#### 2. QueryDSL

> Elasticsearch 提供了一个可以执行查询的Json风格的DSL ( domain-specific language 领域特定语言) . 这个被称为 QueryDSL .  

##### 基本用法

```shell
# sort 排序
GET bank/_search
{
  "query": {
    "match_all": {}
  },
  "sort": [
    {"age": "asc","balance": "asc"}
  ]
}

# from size 分页
GET bank/_search
{
  "query": {
    "match_all": {}
  },
  "from":0,
  "size":10
}
```

##### match

```shell
# match [匹配查询]
## 基本类型(非字符串),精确匹配
GET bank/_search
{
  "query": {
    "match": {
      "account_number": "20"
    }
  }
}

## 字符串,全文检索
## 默认按score排序
GET bank/_search
{
  "query": {
    "match": {
      "address": "Kings"
    }
  }
}

```

##### match_phrase 

```shell
## 短语匹配
## 将需要匹配的值当成一个整体单词(不分词) 进行检索
## 查出address 中包含 mill road 的所有记录,并给出相关性得分
GET bank/_search
{
  "query": {
    "match_phrase": {
      "address": "mill lane"
    }
  }
}

```

##### multi_match 

```shell
## 多字段匹配
## state 或 address包含 mill
GET bank/_search
{
  "query": {
    "multi_match": {
      "query": "mill",
      "fields":["state","address"]
    }
  }
}
```

##### bool

```shell
## 复合查询
## 复合语句可以合并任何其他查询语句,包括复合语句
## 复合语句之间可以互相嵌套,可以表达非常复杂的逻辑

## must: 必须达到must列举的所有条件
GET /bank/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "match": {"gender": "F"}
        },
        {
          "match": {"address": "mill"}
        }
      ]
    }
  }
}

## must_not : 必须不满足must条件
## should: 不满足也行
```

##### filter

```shell
## 结果过滤
## 并不是所有的查询都需要产生分数,特别是那些仅用于"filtering"(过滤)的文档.为了不计算分数 ES 会自动检查场景并且优化查询的执行.


```

##### term

```shell
## 和match一样 匹配某个属性的值 全文检索字段用match, 其他非text字段匹配用term
```



##### aggregate

```shell
## 执行聚合
## 聚合提供了从数据分组和提取数据的能力. 最简单的聚合方法大致等于SQL GROUP BY和SQL聚合函数. 在ES中,您有执行搜索返回hits(命中结果), 并且同时返回聚合结果, 把一个响应中的所有hits(命中结果)分隔开的能力. 这是非常强大且有效的, 您可以执行查询和多个聚合,并且在一次使用中得到各自的返回结果, 使用一次简洁和简化的API来避免网络往返.

# 搜索address 中包含mill 的所有人的年龄分布以及平均年龄, 但不显示这些人的详情
GET /bank/_search
{
  "query": {
    "match": {
      "address": "mill"
    }
  },
  "aggs": {
    "group_by_state": {
      "terms": {
        "field": "age"
      }
    },
    "avg_age":{
      "avg": { 
        "field": "age"
      }
    }
  }
}

```

#### 3. Mapping

##### 1. 字段类型

```shell
# 核心类型
字符串(string) 
		text,keyword
数字类型	
		(Num)long,integer,short,byte,double,float,half_float,scaled_float
日期类型(Date) 
		date
布尔类型(Boolean)
		boolean
二进制类型(binary)
		binary

# 复合类型
数组类型(Array)
		Array 支持不针对特定的类型
对象类型(Object)
		object用于单JSON对象
嵌套类型(Nested)
		nested用于JSON对象
		
# 地理类型(GEO)
地理坐标(Geo-point)
		geo_point 用于描述经纬度坐标
地理图形(Geo-shape)
		geo_shape 用于秒速复杂形状,如多边形
	
# 特定类型
IP类型
		ip 用于描述ipv4 ipv6
不全类型(Completion)
		completion 提供自动完成提示
令牌计数类型(Token count)
		token_count用于统计字符串中的词条数量
附件类型(attachment)
		参考 mapper-attachements 插件,支持将附件如 Microsoft Office格式,Epub ..索引为 attachment 数据类型

抽取类型(Percolator)
		接受特点领域语言(query-dsl)的查询

# 多字段
通常用于为不同目的用不同的方法索引一个字段. 例如:string字段可以映射为一个text字段用于全文检索. 同样可以映射为一个keyword 字段用于排序和聚合. 另外, 你可以使用standard analyzer, English analyzer, french analyzer 来索引一个text字段
这就是 muti-fields的目的. 大多数的数据类型通过fields参数来支持 muti-fields
```

##### 2. 映射

Mapping 是用来定义一个文档(document) , 以及它所包含的属性(field) 是如何存储和索引的. 比如, 使用mapping来定义 :

+ 哪些字符串属性应该被看做全文本属性
+ 哪些属性包含数字,日期或者地理位置
+ 文档中的所有属性是否都能被索引 ( _all 配置 )
+ 日期的格式
+ 自定义映射规则来执行动态添加属性
+ 查看mapping 信息
+ 修改mapping 信息

 ```shell
# 创建映射
PUT bank
{
  "mappings":{
    "properties":{
      "age":{"type":"integer"},
      "email":{"type":"keyword"},
      "name":{"type":"text"}
    }
  }
}

# 添加新的字段映射
PUT bank/_mapping
{
  "properties":{
    "employee-id":{"type":"keyword","index":false}
  }
}

# 对于已经存在的映射字段,不能更新. 必须创建新的索引进行数据迁移

# 数据迁移
## 先创建出 new_twitter 的正确映射. 然后使用如下方式迁移
POST _reindex
{
  "source": {
    "index": "twitter"
  },
  "dest": {
    "index": "new_twitter"
  }
}

 ```

#### 4. 分词

> 一个tokenizer ( 分词器 ) 接收一个字符流, 将之分割为独立的 tokens ( 词元, 通常是独立的单词 ), 然后输出 tokens 流.
>
> 例如, whitespace 遇到空白字符时分割文本. 它会将文本 "Quick brown fox!"分割为[Quick , brown , fox!].
>
> 该tokenizer 还负责记录各个term(词条) 的顺序或 position (用于phrase短语 和 Word proximity 词近邻查询), 以及term 所代表的原始 word 的start 和 end 的character offsets(字符偏移量) .
>
> ES提供了很多内置的分词器, 可以用来构建custom analyzers(自定义分词器)

测试分词器

```shell
POST _analyze
{
  "analyzer": "ik_smart",
  "text": "我是一个程序员!"
}
```



### 整合springboot

**elasticsearch-rest-high-level-client** 官方推荐client

```xml
#pom
<!--es rest client-->
<properties>
  <elasticsearch.version>7.4.2</elasticsearch.version>
</properties>

<dependency>
  <groupId>org.elasticsearch.client</groupId>
  <artifactId>elasticsearch-rest-high-level-client</artifactId>
  <version>7.4.2</version>
</dependency>
```

```java
// 配置文件
@Configuration
public class ESconfig {
    @Bean
    public RestHighLevelClient restHighLevelClient(){
        RestClientBuilder builder = RestClient.builder(new HttpHost("127.0.0.1", 9200, "http"));
        return new RestHighLevelClient(builder);
    }
}
```



### 商品spu es 存储模型

```json
## 设置mapping
PUT product
{
  "mappings": {
    "properties": {
      "skuId":{"type":"long"},
      "spuId":{"type":"keyword"},
      "skuTitle":{"type":"text","analyzer": "ik_smart"},
      "skuPrice":{"type":"keyword"},
      "skuImg":{"type":"keyword","index": false,"doc_values": false},
      "saleCount":{"type":"long"},
      "hasStock":{"type":"boolean"},
      "hotScore":{"type":"long"},
      "brandId":{"type":"long"},
      "categoryId":{"type":"long"},
      "brandName":{"type":"keyword","index": false,"doc_values": false},
      "brandImg":{"type":"keyword","index": false,"doc_values": false},
      "categoryName":{"type":"keyword","index": false,"doc_values": false},
      "attrs":{
        "type": "nested",
        "properties": {
          "attrId":{"type":"long"},
          "attrName":{"type":"keyword","index": false,"doc_values": false},
          "attrValue":{"type":"keyword"}
        }
      }
    }
  }
}
```





